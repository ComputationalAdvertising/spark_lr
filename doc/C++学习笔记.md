## C++学习笔记

### [C++学习网站－理论部分](http://c.biancheng.net/cpp/biancheng/cpp/) \\(\qquad\\) [C++官网－接口与示例](http://www.cplusplus.com/)
--

+ author: zhouyongsdzh@foxmail.com
+ date: 20160112


### 目录

+ 第1部分：C++基础
+ 第2部分：容器＋库函数
+ 第3部分：面向对象编程
+ 第4部分：构建C++大型系统



### 基本概念

+ 指针与引用

1.指针和引用的定义和性质区别：

(1)指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：

```
int a=1;int *p=&a;
int a=1;int &b=a;
```
上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。

而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。

(2)可以有const指针，但是没有const引用；

(3)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）

(4)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；

(5)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。

(6)"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；

(7)指针和引用的自增(++)运算意义不一样；

+ 命名空间（namespace）

	为什么需要将函数定义在命名空间中呢？这其实是**为了避免变量或函数重命名的问题。**
	
	>试想，一个项目组内多个工程师进行开发，有可能会出现全局变量或函数重名的现象，而如果每个人都定义了自己的命名空间，就可以解决这个问题，即使重名，只要分属不同的命名空间就不会引起问题。

    这样大家应该明白了，命名空间就是将多个变量和函数等包含在内，使其不会与命名空间外的任何变量和函数等发生重命名的冲突。

### 基础篇－Class

+ 创建class对象的两种方法

	+ 方法1: 

		```
		ClassName object(param);
		```

		这样就声明了一个ClassName类型的object对象，C++会为它分配足够的存放对象所有成员的存储空间。

		> 注意：为节省存储空间，C++创建对象时仅分配用于保存数据成员的空间，而类中定义的成员函数则被分配到存储空间中的一个公用区域，由该类的所有对象共享。例如，我定义了一个这样的类：

		```
	class Rec
	{
   		public:
		   Rec(int width,int height);
		   ~Rec();
		   int getArea();
	   private:
   			int Rwidth;
		   int Rheight;
	};
		```
	
		当你Rec myRec(5,5);这样创建一个myRec对象，然后打印出sizeof(myRec);的时候，会得到 8 这个结果。
		>因为myRec中有2个int类型的数据成员，一个int成员占4个字节，所以myRec对象占8个字节。 
		
		**这种方法创建的对象，内存分配是分配到栈中的，由C++缺省创建和撤销，自动调用构造函数和析构函数。**

		> 注意：该方法创建的对象调用类方法时，必须用“.”，而不能用“->”.如myRec.getArea();

	+ 方法2：

		```
		ClassName *object=new ClassName(param);
		delete object;
		```
		
		这种方法跟java有点类似，（与Java）相同的是，它们都是在**堆上分配内存**来创建对象的（与上不同）；不同的是，C++用new创建对象时返回的是一个对象指针，object指向一个ClassName的对象，**C++分配给object的仅仅是存放指针值的空间**。而且，用new 动态创建的对象必须用delete来撤销该对象。只有delete对象才会调用其析构函数。
		
		> 注意：new创建的对象不是用“*”或“.”来访问该对象的成员函数的，而是用运算符“->”;
例如：

		```
		Rec *rec=new Rec(3,4);
      rec->getArea();
      delete rec;
      ```
		顺便提一下：一般来说，**编译器将内存分为三部分：静态存储区域、栈、堆。静态存储区主要保存全局变量和静态变量，栈存储调用函数相关的变量、地址等，堆存储动态生成的变量。**
		
		> 在c中是指由malloc,free运算产生释放的存储空间，在c++中就是指new和delete运算符作用的存储区域。
		
		
+ 命名空间：namespace

###  第1部分：C++基础


+ [内联函数 inline](http://c.biancheng.net/cpp/biancheng/view/134.html)

	> 调用函数时需要一定的时间和空间的开销。C++提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。
	> 
	> ```inline void swap(int &a, int &b) {} ``` 在函数定义处加```inline```才有意义。 
	
### 第2部分：容器＋库函数


### 第3部分：面向对象编程


+ [多态性概念](http://c.biancheng.net/cpp/biancheng/view/242.html)

	> polymorphism. 
	>
	> 表述：**向不同的对象发送同一个消息， 不同的对象在接收时会产生不同的行为（即方法）**。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。
	>
	> 两种实现：静态多态性和动态多态性。
	>
	> 1. 静态多态性：通过[函数重载](http://c.biancheng.net/cpp/biancheng/view/135.html)和[运算符重载](http://c.biancheng.net/cpp/biancheng/cpp/rumen_10/)实现，又称为编译时的多态性；
	> 2. 动态多态性：通过虚函数实现，称为运行时的多态性；
	>
	> 虚函数要解决的问题：**当一个基类被继承为不同的派生类时，各派生类可以使用与基类成员相同的成员函数名，如果在运行时用同一个基类指针调用类对象的成员函数，会调用哪个对象的成员函数？** 也就是说，多态性是“一个接口，多种 方法”。

+ [虚函数 virtual](http://c.biancheng.net/cpp/biancheng/view/244.html)
	
	> C++虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类**指针或引用**来访问基类和派生类中的同名函数。
	>
	> 当把基类的某个成员函数声明为虚函数后，允许在其派生类中对该函数重新定义，赋予它新的功能，并且可以通过指向基类的指针指向同一类族中不同类的对象，从而调用其中的同名函数。
	> 
	```
	class Student {public: virtual void display(); }
	class Gradient : public Student {public: void display(); }  // 继承
	Gradient grad;	// 定义派生类对象
	Student *p = &grad; 	// 定义指向基类的指针，指向同一类族不同类的对象
	p->display();		// 执行的是派生类的display函数
	```
	>
	> **由虚函数实现的动态多态性就是：同一类族中不同类的对象，对同一函数调用作出不同的响应。**
	
+ [友元函数、友元类 friend](http://c.biancheng.net/cpp/biancheng/view/211.html)
+ []()


### 第4部分：构建C++大型系统
